 
##   3.4.2: Custom Page Modules

### Custom Page Modules

Considering what we've covered in regard to page mappings, you can see that JavaScript page modules are quite similar to Stencil page templates, in that a specific page type is intrinsically connected to a certain entry point.

This means that every single product page, for example, is tied to the same entry point and same JS code. With templates, we discovered we had the option of defining _custom_ templates for certain entities (products, categories, brands, and web pages), which can be applied on a selective basis. Can we do the same with JavaScript modules?

The `customClasses` variable in `assets/js/app.js` is defined for exactly this purpose. While you're not able to independently control the module that is assigned to a given entity, this mapping allows associating a module with a custom template.

`customClasses` is initially empty in Cornerstone (naturally, since there are initially no custom templates to map to). But if you have a custom template you want to associate to a custom page module, add two entries (one with a Mac/Linux-style file path and one with a Windows-style path) with the path of the custom template as the key and the right import function as the value.

```javascript
const customClasses = {
    'pages/custom/product/my-custom-view': () => import(
        './theme/custom/product/my-custom-view'
    ),
    'pages\\custom\\product\\my-custom-view': () => import(
        './theme/custom/product/my-custom-view'
    )
};
```

With the above configuration, any product page that loads using the template `pages/custom/product/my-custom-view.html` will also load `assets/theme/custom/product/my-custom-view.js` as its main entry point instead of the usual `product.js`.

> #### An Aside
> 
> It's actually a mystery to me why both Linux and Windows versions of the template path are recommended, since the value this key is matched to comes directly from the BigCommerce back-end; it's injected into the "context" object in the page source code. But I recommend following the convention as long as it's part of the official documentation.

Naturally, you'll often end up directly extending the default JS class for the appropriate page type, rather than `PageManager`, to avoid needing to duplicate logic that still applies to your custom class. The class defined in the custom module referenced above would likely extend `Product`:

```javascript
import Product from '../../../theme/product';

export default class MyCustomView extends Product {
    constructor(context) {
        super(context);
        ...
    }

    onReady() {
        super.onReady();
        ...
    }
}
```

  